mono for Debian
---------------

1. Documentation can be found in the seperated monodoc packages.

2. Supported Processor Architectures
    JIT:
    Linux/x86
    Linux/PPC
    Linux/S390
    Solaris/SPARC
    MacOS/PPC

    Interpreter:
    Linux/x86
    Linux/PPC
    S390
    StrongARM
    SPARC
    SPARC v9
    HPPA
 
3. Purge your ~/.wapi directory if you see messages like:

   ** (/tmp/hello.exe:23770): WARNING **: Shared memory sanity check
   failed.

   ** (/tmp/hello.exe:23770): WARNING **: Failed to attach shared memory!
   Falling back to non-shared handles

   Reason:

   02:00:00 < totte> .wapi is the shared memory file folder used to handle process.start and someother functions for our IO lib

4. Provisoric virtual packages:

   - mono-assemblies-base is the core package, arch-independent. It does
      NOT include arch-dependent components for portability reasons
   - mono-assemblies-arch is the package which arch dependent files. It
      also depends on mono-assemblies-base and provides "cli-runtime"
   - cli-runtime: depend on it to get the whole assemblies suite
   - cli-virtual-machine: depend on it to get working /usr/bin/cli with
      the core assemblies parts (no arch-depent part)
      
5. (for developers) Package installation policy be found on
   http://wiki.debian.net/?MonoConventions . Recent snapshot:

| MONO Conventions Version: 0.1.2
| 
| Conventions for packaging Mono applications/libraries for Debian GNU/Linux.
| 
| .NET Framework issues:
| 
|   * Depend on every library package that you need. Note that some applications
|     or libs may open them via ldopen, so you need to track the dependencies
|     manually
|   * To get an interpreter, depend on:
| 
| mono-jit | cli-virtual-machine
| 
|   * To run the interpreter/jit-compiler, run //usr/bin/cli. This is a link to
|     the "best" interpreter choosen with update-alternatives. Currently mono or
|     mint.
|   * To get the compiler, depend on
| 
| mono-mcs | c-sharp-compiler
| 
| Note that there are no c-sharp-compiler alternatives yet, it is not clear
| whether we will create the c-sharp-compiler alternative entry. (Portable .NET
| maybe comming into debian some day)
| 
| Library issues;
| 
|   * base assemblies are packaged. Currently they go into /usr/lib which is not
|     the best location (aliens in the system). Ideally, we should get the GAC
|     soon so the DLLs could be moved to separate location(s) without having a
|     config (dll mapping) hell in /etcmono/config. See new-installation-proposal
|     below.
| 
| Applications package issues... Possible cases:
| 
|   * application packages:
|       + (bad idea) put the .exe into /usr/bin and let the user work with
|         binfmt_support. Drawbacks:
|           o executable with useless suffixes in binary paths
|           o unnessesarly longer startup time -- kernels goes trough the binfmt
|             path: run binfmt-cli-detector (on Debian executed trough a Perl
|             wrapper which opens the file, checks the type, etc.), then run the
|             actual interpreter
|           o compatibility: $user may not have binfmt_misc in the kernel
| 
|       + general solution: a shell wrapper. On Debian, it runs //usr/bin/cli
|         with the application name and parameters.
| 
|     Pro:
| 
| 
|           o can be modified easily
| 
|     Contra:
| 
| 
|           o shell invocation, a bit bloat that makes start time longer
| 
|       + a binary wrapper: an executable program which does the same thing as a
|         shell wrapper.
| 
|     Pro:
| 
| 
|           o Fast
| 
|     Contra:
| 
| 
|           o cannot be modified. Could use a standard scheme for locating the
|             EXE files, see below.
| 
| Naming:
| 
|   * The official name of the Mono Project is: Mono, mono:: or mono. To keep it
|     unified (more transperant to the user) it should be always called "Mono",
|     not MONO, not mono, not mono:: even no mixing with .NET in it. The
|     explaination of Mono goes into the package long description.
| 
| THE PLAN (new policy proposal)
| 
| We create the directory //usr/share/dotnet (not in //usr/lib since all of this
| is arch-independent, interpreted code). In this "dot-net area", we create:
| 
|   * /usr/share/dotnet/lib (with DLLs, this path needs to be known by the
|     runtime. As well as usr/lib for all the "incompatible" apps. Hm. We need
|     the GAC). In this directory should go general libs, which are shared
|     between applications. Application specific libs should goto their dotnet
|     $package directory.
| 
|   * /usr/share/dotnet/bin (with .EXE executables, OR with symlinks to the
|     $package dirs. For example, there is a symlink called usr/share/dotnet/bin/
|     normalize which points to ../monodoc).
| 
|   * /usr/share/dotnet$package_name (where the actual package and its relevant
|     files are located. For example, the monodoc.exe, assembler.exe etc., and
|     the documentation directory). The $source_package_name should be used if it
|     makes sense, some programs don't like to be seperated too much (symlink
|     hell is also no solution).
| 
|   * All .exe filesh must have the executable flag (+x), to keep compatibility
|     with binfmt.
| 
| Why all this? First, to have reliable file locations. Second, to create a good
| generic application invocation tool. Shell wrappers for each application are
| the simplest and quite acceptable way. For those who are lazy to write them, I
| suggest an allround-program that looks for the right EXE binary to start. We
| store it as //usr/bin/cli-wrapper. The application package would install a
| symlink cli-wrapper -> //usr/bin/program-name (without .exe!). The cli-wrapper
| is in the mono-common package and part of the cli-virtual-machine. What would
| the wrapper do on start? It checks argv0 (which is "normalize", for example).
| It looks for //usr/bin/normalize.exe (and executes it if found), then for //usr
| /share/dotnet/bin/normalize.exe, then for //usr/share/dotnet/bin/normalize/
| normalize.exe. The last one is a directory symlink, pointing to ../monodoc.
| These all is especially useful if the application has additional assemblies in
| its startup directory, or looks for additional config files there or such
| things. The libs placed in /usr/share/dotnet/lib are in the search path when
| the cli-wrapper is used, if you don't use the cli-wrapper (shell scripts
| instead) you need to set MONO_PATH yourself!

PS: Some comparisons (not real benchmarks!), testing different
invocation methods:

  The "native" method via exec, binfmt_misc, binfmpt-support (Perl
  script), binfmt-detector-cli:

time for x in `seq 1000` ; do ./hello.exe > /dev/null; done

real    3m2.969s
user    2m8.060s
sys     0m14.540s

  The shell wrapper method using mono:

time for x in `seq 1000` ; do ./hello.sh > /dev/null; done

real    2m43.146s
user    1m45.990s
sys     0m11.140s

  Using "cli-wrapper" with a symlink:

time for x in `seq 1000` ; do ./hello > /dev/null; done

real    2m23.958s
user    1m32.720s
sys     0m9.640s

  The "interpreter" method using mono:

time for x in `seq 1000` ; do /usr/bin/cli ./hello.exe > /dev/null; done

real    2m23.699s
user    1m33.140s
sys     0m8.920s

 Eduard Bloch <blade@debian.org> -- Thu, 15 Apr 2004 23:32:45 +0200
