#!/usr/bin/perl -w

=head1 NAME

dh_netdeps - calculates .NET dependencies

=cut

use strict;
use File::Find;
use Debian::Debhelper::Dh_Lib;

#eval 'use Debian::Debhelper::Dh_Lib';
#print "You need to install the debhelper package in order to use this program!" if $@;

=head1 SYNOPSIS

B<dh_python> [S<I<debhelper options>>]

=head1 DESCRIPTION

dh_python is a debhelper program that is responsible for generating the
${python:Depends} substitutions and adding them to substvars files. It
will also add a postinst and a prerm script if required.

The program will look at python scripts and modules in your package, and
will use this information to generate a dependency on python, with the
current major version, or on pythonX.Y if your scripts or modules need a
specific python version. The dependency will be substituted into your
package's control file wherever you place the token "${python:Depends}".

If some modules need to be byte-compiled at install time, appropriate
postinst and prerm scripts will be generated. If already byte-compiled
modules are found, they are removed.

If you use this program, your package should build-depend on python.

=head1 OPTIONS

=over 4

=item I<module dirs>

If your package installs python modules in non-standard directories, you
can make dh_python check those directories by passing their names on the
command line. By default, it will check /usr/lib/site-python,
/usr/lib/$PACKAGE, /usr/share/$PACKAGE, /usr/lib/games/$PACKAGE,
/usr/share/games/$PACKAGE and /usr/lib/python?.?/site-packages.

Note: only /usr/lib/site-python, /usr/lib/python?.?/site-packages and the
extra names on the command line are searched for binary (.so) modules.

=item B<-V> I<version>

If the .py files your package ships are meant to be used by a specific
pythonX.Y version, you can set this option with the desired X.Y python
version.
Do not use if you ship modules in /usr/lib/site-python.

=item B<-n>, B<--noscripts>

Do not modify postinst/postrm scripts.

=back

=head1 CONFORMS TO

Debian policy, version 3.5.7

Python policy, version 0.3.7

=cut

init();

my $cli = '/usr/bin/cli';

# The current python major version
# my $python_major;
my $mono_version = `$cli -V 2>&1`;

if ( !-x "/usr/bin/monodis" ) {
    error(
"Package mono-utils is not installed, aborting. (Probably forgot to Build-Depend on mono-utils.)"
    );
}

if ( system "grep \"Build-Dep.*mono-utils\" debian/control" ) {
    warning("Warning! No Build-Depends on mono-utils!");
}

if ( !defined $mono_version || $mono_version eq "" ) {
    error( "Mono is not installed, aborting. (Probably forgot to
  Build-Depend on cli-virtual-machine.)"
    );
}
elsif ( $mono_version =~ /(mint|version)\ ([\d\.]+)/ ) {
    $mono_version = "$2";
}
else {
    error("Unable to parse Mono version out of \"$mono_version\".");
}

# The next python version
#my $python_nextversion = $python_version + 0.1;
#my $python_nextmajor = $python_major + 1;
#
#my @python_allversions = ('1.5','2.1','2.2','2.3');
#foreach (@python_allversions) {
#	s/^/python/;
#}

# Check for -V
my $usemono = $mono_version;
if ( $dh{V_FLAG_SET} ) {
    $usemono = $dh{V_FLAG};
}

# Cleaning the paths given on the command line
foreach (@ARGV) {
    s#/$##;
    s#^/##;
}

my $fh;
my %libdata;
open( $fh, "cat /var/lib/dpkg/info/*.netlibs debian/*/DEBIAN/netlibs 2>/dev/null |" );
while (<$fh>) {
    /(\S+)\s+(\S+)\s+(\w.*)\n?/;
    $libdata{"$1/$2"} = $3;
}

## shared code
my %shlibdata;
open( $fh, "cat /var/lib/dpkg/info/*.shlibs 2>/dev/null |" );
while (<$fh>) {
    /(\S+)\s+(\S+)\s+(\w.*)\n?/;
    $shlibdata{"$1.so.$2"} = $3;
}


sub extraDeps {
   my $config=$_[0].".config";
   my $ret=undef;
   if( -r $config) {
      $config=`cat $config`;
      while($config=~s/\Wtarget\W*=\W*(\w[\w.\-\d]+)//) {
         $ret.= (", ".$shlibdata{$1}) if(defined($shlibdata{$1}));
      }
   }
   $ret=~s/^, //;
   print "TEST: $ret\n";
   return $ret;
}

## /shared code



#print (values %libdata);
#exit 1;

foreach my $package ( @{ $dh{DOPACKAGES} } ) {
    my $tmp = tmpdir($package);
    my %deps;
    my %depkgs;

    delsubstvar( $package, "net:Depends" );    # for idempotency

    # find binaries
    # total falsch hier
    find sub {
       my $vers;
       return unless -f and /\.(exe|dll)$/;
       local *F;
       return unless open F, "monodis --assemblyref $_|";
       our( $vers, $name, $key );
       while (<F>) {
          $vers = $1 if /Version=(.*)\n/;
          $name = $1 if /Name=(.*)\n/;

          if (/0x\S+:.([ABCDEF0123456789 ]+)\n/) {
             $key = $1;
             $key =~ s/\ //g;
             $key = $vers . "__" . lc($key);
             my $compat = "$name/$key";
             if(!defined($libdata{$compat})) {
                warning("Warning! No Debian dependency data for $name ($key)!");
             }
             else {
                $depkgs{$libdata{$compat}} = 1;
             }
             #print "ok, ".$deps{ "$name/$vers" . "__" . lc($key) };
          }
       }
       close F;
    }, $tmp;

    #print( keys %depkgs );
    #exit 1;

    addsubstvar( $package, "net:Depends",
        "mono-jit (>> $mono_version) | cli-virtual-machine".(%depkgs?join(", ", "", (keys %depkgs)):""));

    #     # finaly resolve the version and add it to substvars
    #     foreach my $pkg (keys %deps) {
    #        my $version = $minvLoc{$pkg};
    #        $version =~ s#[\(\)]##g if $version;
    #        if(!$version && `dpkg -s $pkg` =~ /^Version:\s*(\S+)/m) {
    #           $version = ">= $1";
    #           # FIXME add an option to match the exact versions
    #           # match only the upstream version
    #           if(!0) {
    #              $version =~ s/-[^-]+$//;
    #              $version =~ s/=/>/;
    #           }
    #        }
    #        addsubstvar($package, "net:Depends", $pkg, $version);
    #     }
}

=head1 SEE ALSO

L<debhelper(7)>

This program may be a part of debhelper or mono-utils.

=head1 AUTHOR

Eduard Bloch <blade@debian.org>, partialy based on code from Brendan O'Dea <bod@debian.org>.

=cut

