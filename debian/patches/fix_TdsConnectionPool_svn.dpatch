#! /bin/sh /usr/share/dpatch/dpatch-run
## fix_TdsConnectionPool_r105424_r106448_107325.dpatch by Mirco Bauer <meebey@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Backport of upstream SVN trunk to fix connection pool leaks/stalls, see:
## DP: https://bugzilla.novell.com/show_bug.cgi?id=360157
## DP: r105424:
## DP: Remove unnecessary locks and code refactoring
## DP: r105432:
## DP: Update according to the new return type of TdsConnectionPool.GetConnectionPool()
## DP: r105433:
## DP: Member to keep track of pool status
## DP: r105719:
## DP: Do not call tds.Reset () as it is already done in the connection pool.
## DP: r106448:
## DP: Honor timeout and throw appropriate exception when connections are not available
## DP: r107325:
## DP: TdsConnectionPool.cs: When pooled connection cannot be reset, remove
## DP: it from pool and allow slot to be re-used for a newly established
## DP: connection. Fixes part of bug #360157. When pool is full, and no
## DP: connection becomes available before the connect timeout has elapsed,
## DP: then throw an InvalidOperationException instead of a SqlException.

@DPATCH@
diff -urNad mono-1.9+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs mono-1.9+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs
--- mono-1.9+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs	2008-01-29 23:04:15.000000000 +0100
+++ mono-1.9+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/Tds.cs	2008-07-08 21:15:49.000000000 +0200
@@ -102,6 +102,8 @@
 		bool isResultRead = false;
 		bool LoadInProgress = false;
 
+		internal int poolStatus = 0;
+
 		#endregion // Fields
 
 		#region Properties
diff -urNad mono-1.9+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs mono-1.9+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs
--- mono-1.9+dfsg~/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs	2007-11-08 23:11:23.000000000 +0100
+++ mono-1.9+dfsg/mcs/class/Mono.Data.Tds/Mono.Data.Tds.Protocol/TdsConnectionPool.cs	2008-07-08 21:15:49.000000000 +0200
@@ -3,6 +3,7 @@
 //
 // Author:
 //   Lluis Sanchez Gual (lluis@ximian.com)
+//   Christian Hergert (christian.hergert at gmail.com)
 //
 // Copyright (C) 2004 Novell, Inc.
 //
@@ -28,16 +29,23 @@
 // WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
 
-using Mono.Data.Tds.Protocol;
 using System;
+#if NET_2_0
+using System.Collections.Generic;
+#else
 using System.Collections;
+#endif
 using System.Threading;
 
 namespace Mono.Data.Tds.Protocol 
 {
 	public class TdsConnectionPoolManager
 	{
+#if NET_2_0
+		Dictionary <string, TdsConnectionPool> pools = new Dictionary <string, TdsConnectionPool> ();
+#else
 		Hashtable pools = new Hashtable ();
+#endif
 		TdsVersion version;
 		
 		public TdsConnectionPoolManager (TdsVersion version)
@@ -49,7 +57,12 @@
 		{
 			lock (pools)
 			{
-				TdsConnectionPool pool = (TdsConnectionPool) pools [connectionString];
+				TdsConnectionPool pool = null;
+#if NET_2_0
+				pools.TryGetValue (connectionString, out pool);
+#else
+				pool = (TdsConnectionPool) pools [connectionString];
+#endif
 				if (pool == null) {
 					pool = new TdsConnectionPool (this, info);
 					pools [connectionString] = pool;
@@ -58,12 +71,13 @@
 			}
 		}
 		
-		public Hashtable GetConnectionPool ()
+#if NET_2_0
+		public IDictionary <string, TdsConnectionPool> GetConnectionPool ()
+#else
+		public IDictionary GetConnectionPool ()
+#endif
 		{
-			lock (pools)
-			{
-				return pools;
-			}
+			return pools;
 		}
 		
 		public virtual ITds CreateConnection (TdsConnectionInfo info)
@@ -102,20 +116,34 @@
 		public int PoolMinSize;
 		public int PoolMaxSize;
 	}
-	
+
 	public class TdsConnectionPool
 	{
-		ArrayList list = new ArrayList ();
+		ITds[] list;
 		TdsConnectionInfo info;
-		bool initialized;
 		bool pooling = true;
-		int activeConnections = 0;
 		TdsConnectionPoolManager manager;
-
+		ManualResetEvent connAvailable;
+		
 		public TdsConnectionPool (TdsConnectionPoolManager manager, TdsConnectionInfo info)
 		{
+			int n = 0;
+			
 			this.info = info;
 			this.manager = manager;
+			list = new ITds[info.PoolMaxSize];
+			
+			// Placeholder for future connections are at the beginning of the array.
+			for (; n < info.PoolMaxSize - info.PoolMinSize; n++)
+				list [n] = null;
+
+			// Pre-populate with minimum number of connections
+			for (; n < list.Length; n++) {
+				list [n] = CreateConnection ();
+			}
+			
+			// Event that notifies a connection is available in the pool
+			connAvailable = new ManualResetEvent (false);
 		}
 
 		public bool Pooling {
@@ -128,110 +156,118 @@
 		public ITds GetConnection ()
 		{
 			ITds connection = null;
-			lock (list)
-			{
-				if (!initialized) 
-				{
-					for (int n = 0; n < info.PoolMinSize; n++)
-						list.Add (CreateConnection ());
-					initialized = true;
-				}
-				do {
-					if (list.Count > 0)
-					{
-						// There are available connections
-						connection = (ITds) list [list.Count - 1];
-						list.RemoveAt (list.Count - 1);
+			int index;
+
+		retry:
+			// Reset the connection available event
+			connAvailable.Reset ();
+
+			index = list.Length - 1;
+			
+			do {
+				connection = list [index];
+
+				if (connection == null) {
+					// Attempt take-over of array position
+					connection = CreateConnection ();
+					(connection as Tds).poolStatus = 1;
+#if NET_2_0
+					if (Interlocked.CompareExchange<ITds> (ref list [index], connection, null) != null) {
+#else
+					if (Interlocked.CompareExchange (ref (list as object[]) [index], connection, null) != null) {
+#endif
+						// Someone beat us to the punch
+						connection = null;
+					} else {
+						continue;
+					}
+				} else {
+					if (Interlocked.CompareExchange (ref (connection as Tds).poolStatus, 1, 0) != 0) {
+						// Someone else owns this connection
+						connection = null;
+					} else {
 						if (!connection.Reset ()) {
-							try {
-								connection.Disconnect ();
-							} catch {}
-							connection = null;
+							ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+							// remove connection from pool
+							list [index] = connection = null;
+							// allow slot be re-used in same run
+							continue;
+						} else {
 							continue;
 						}
 					}
+				}
+				
+				index--;
+				
+				if (index < 0) {
+					// TODO: Maintain a list of indices of released connection to save some loop over
+					// Honor timeout - if pool is full, and no connections are available within the 
+					// timeout period - just throw the exception
+					if (info.Timeout > 0 
+						&& !connAvailable.WaitOne (new TimeSpan (0, 0, info.Timeout), true))
+							throw new InvalidOperationException (
+								"Timeout expired. The timeout period elapsed before a " +
+								"connection could be obtained. A possible explanation " +
+								"is that all the connections in the pool are in use, " +
+								"and the maximum pool size is reached.");
+					goto retry;
+				}
 
-					if (connection == null && activeConnections < info.PoolMaxSize)
-					{
-						// No connections available, but the connection limit
-						// has not been reached yet, so a new one can be created
-						connection = CreateConnection();
-					}
-
-					// No available connections in the pool
-					// Wait for somewone to release one.
-					if (connection == null)
-					{
-						Monitor.Wait (list);
-					}
-				} 
-				while (connection == null);
-			}
+			} while (connection == null);
 
 			return connection;
 		}
 
-		public void ReleaseConnection (ITds tds)
+		public void ReleaseConnection (ITds connection)
 		{
-			lock (list)
-			{
-				list.Add (tds);
-				Monitor.Pulse (list);
-			}
+			((Tds) connection).poolStatus = 0;
+			connAvailable.Set ();
 		}
 
 #if NET_2_0
-		public void ReleaseConnection (ref ITds tds)
+		public void ReleaseConnection (ref ITds connection)
 		{
-			lock (list)
-			{
-				if (pooling == false) {
-					try {
-						tds.Disconnect ();
-					} catch {}
-					tds = null;
-				} else {
-					list.Add (tds);
-					Monitor.Pulse (list);
-				}
+			if (pooling == false) {
+				int index = Array.IndexOf (list, connection);
+				ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+				list [index] = connection = null;
+			} else {
+				((Tds) connection).poolStatus = 0;
 			}
+			connAvailable.Set ();
 		}
 
 		public void ResetConnectionPool ()
 		{
-			lock (list)
+			ITds connection = null;
+			int index = list.Length - 1;
+
+			while (index >= 0)
 			{
-				ITds connection = null;
-				while (list.Count > 0) {
-					// There are available connections
-					connection = (ITds) list [list.Count - 1];
-					list.RemoveAt (list.Count - 1);
+				connection = list [index];
+
+				if (Interlocked.CompareExchange (ref ((Tds) connection).poolStatus, 1, 0) == 0) {
 					if (!connection.Reset ()) {
-						try {
-							connection.Disconnect ();
-						} catch {}
-						connection = null;
+						ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+						list [index] = connection = null;
+						connAvailable.Set ();
 					}
 				}
+
+				index--;
 			}
 		}
 
 		public void ResetConnectionPool (ITds connection)
 		{
-			lock (list)
-			{
-				if (list.Count > 0) {
-					// There are available connections
-					int index = list.IndexOf (connection);
-					if (index != -1) {
-						list.RemoveAt (index);
-						if (!connection.Reset ()) {
-							try {
-								connection.Disconnect ();
-							} catch {}
-							connection = null;
-						}
-					}
+			int index = Array.IndexOf (list, connection);
+
+			if (index != -1) {
+				if (connection != null && !connection.Reset ()) {
+					ThreadPool.QueueUserWorkItem (new WaitCallback (DestroyConnection), connection);
+					list [index] = connection = null;
+					connAvailable.Set ();
 				}
 			}
 		}
@@ -239,10 +275,21 @@
 		
 		ITds CreateConnection ()
 		{
-			activeConnections++;
 			return manager.CreateConnection (info);
 		}
 		
+		void DestroyConnection (object state)
+		{
+			ITds connection = state as ITds;
+			if (connection != null) {
+				try {
+					connection.Disconnect ();
+				} finally {
+					connection = null;
+				}
+			}
+		}
+		
 		#endregion // Methods
 	}
 }
diff -urNad mono-1.9+dfsg~/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs mono-1.9+dfsg/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs
--- mono-1.9+dfsg~/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs	2007-11-08 23:13:07.000000000 +0100
+++ mono-1.9+dfsg/mcs/class/System.Data/System.Data.SqlClient/SqlConnection.cs	2008-07-08 21:16:16.000000000 +0200
@@ -51,6 +51,9 @@
 using System.Net.Sockets;
 using System.Text;
 using System.Xml;
+#if NET_2_0
+using System.Collections.Generic;
+#endif
 
 namespace System.Data.SqlClient {
 	[DefaultEvent ("InfoMessage")]
@@ -570,8 +573,6 @@
 						pool.ReleaseConnection (tds);
 					throw;
 				}
-			} else if (connectionReset) {
-				tds.Reset ();
 			}
 
 			disposed = false; // reset this, so using () would call Close ().
@@ -1684,7 +1685,11 @@
 
 		public static void ClearAllPools ()
 		{
+#if NET_2_0
+			IDictionary <string, TdsConnectionPool> pools = SqlConnection.sqlConnectionPools.GetConnectionPool ();
+#else			
 			Hashtable pools = SqlConnection.sqlConnectionPools.GetConnectionPool ();
+#endif
 			foreach (TdsConnectionPool pool in pools.Values) {
 				if (pool != null) {
 					pool.ResetConnectionPool ();
