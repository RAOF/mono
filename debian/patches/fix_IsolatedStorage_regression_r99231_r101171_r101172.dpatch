#! /bin/sh /usr/share/dpatch/dpatch-run
## fix_IsolatedStorage_regression_r99231_r101171_r101172.dpatch by  <jms@osc-franzibald>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Fix IsolatedStorage regression causing exceptions on subdirectories
## DP: Taken from SVN revision r99231, r101171, r101172

@DPATCH@
diff -urNad mono-1.9.1+dfsg~/mcs/class/corlib/System.IO/Path.cs mono-1.9.1+dfsg/mcs/class/corlib/System.IO/Path.cs
--- mono-1.9.1+dfsg~/mcs/class/corlib/System.IO/Path.cs	2008-10-10 14:41:26.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/corlib/System.IO/Path.cs	2008-10-10 14:41:40.000000000 +0100
@@ -69,7 +69,7 @@
 		internal static readonly string DirectorySeparatorStr;
 		public static readonly char VolumeSeparatorChar;
 
-		private static readonly char[] PathSeparatorChars;
+		internal static readonly char[] PathSeparatorChars;
 		private static readonly bool dirEqualsVolume;
 
 		// class methods
diff -urNad mono-1.9.1+dfsg~/mcs/class/corlib/System.IO.IsolatedStorage/IsolatedStorageFile.cs mono-1.9.1+dfsg/mcs/class/corlib/System.IO.IsolatedStorage/IsolatedStorageFile.cs
--- mono-1.9.1+dfsg~/mcs/class/corlib/System.IO.IsolatedStorage/IsolatedStorageFile.cs	2008-10-10 14:41:26.000000000 +0100
+++ mono-1.9.1+dfsg/mcs/class/corlib/System.IO.IsolatedStorage/IsolatedStorageFile.cs	2008-10-10 14:41:40.000000000 +0100
@@ -453,13 +453,36 @@
 
 		public void CreateDirectory (string dir)
 		{
-			directory.CreateSubdirectory (dir);	
+			if (dir == null)
+				throw new ArgumentNullException ("dir");
+
+			if (dir.IndexOfAny (Path.PathSeparatorChars) < 0) {
+				if (directory.GetFiles (dir).Length > 0)
+					throw new IOException (Locale.GetText ("Directory name already exists as a file."));
+				directory.CreateSubdirectory (dir);
+			} else {
+				string[] dirs = dir.Split (Path.PathSeparatorChars);
+				DirectoryInfo dinfo = directory;
+
+				for (int i = 0; i < dirs.Length; i++) {
+					if (dinfo.GetFiles (dirs [i]).Length > 0)
+						throw new IOException (Locale.GetText (
+							"Part of the directory name already exists as a file."));
+					dinfo = dinfo.CreateSubdirectory (dirs [i]);
+				}
+			}
 		}
 
 		public void DeleteDirectory (string dir)
 		{
-			DirectoryInfo subdir = directory.CreateSubdirectory (dir);
-			subdir.Delete ();
+			try {
+				DirectoryInfo subdir = directory.CreateSubdirectory (dir);
+				subdir.Delete ();
+			}
+			catch {
+				// hide the real exception to avoid leaking the full path
+				throw new IsolatedStorageException (Locale.GetText ("Could not delete directory '{0}'", dir));
+			}
 		}
 
 		public void DeleteFile (string file)
@@ -475,7 +498,28 @@
 
 		public string[] GetDirectoryNames (string searchPattern)
 		{
-			DirectoryInfo[] adi = directory.GetDirectories (searchPattern);
+			if (searchPattern == null)
+				throw new ArgumentNullException ("searchPattern");
+
+			// note: IsolatedStorageFile accept a "dir/file" pattern which is not allowed by DirectoryInfo
+			// so we need to split them to get the right results
+			string path = Path.GetDirectoryName (searchPattern);
+			string pattern = Path.GetFileName (searchPattern);
+			DirectoryInfo[] adi = null;
+			if (path == null || path.Length == 0) {
+				adi = directory.GetDirectories (searchPattern);
+			} else {
+				DirectoryInfo[] subdirs = directory.GetDirectories (path);
+				// we're looking for a single result, identical to path (no pattern here)
+				// we're also looking for something under the current path (not outside isolated storage)
+				if ((subdirs.Length == 1) && (subdirs [0].Name == path) && (subdirs [0].FullName.IndexOf (directory.FullName) >= 0)) {
+					adi = subdirs [0].GetDirectories (pattern);
+				} else {
+					// CAS, even in FullTrust, normally enforce IsolatedStorage
+					throw new SecurityException ();
+				}
+			}
+			 
 			return GetNames (adi);
 		}
 
@@ -489,7 +533,28 @@
 
 		public string[] GetFileNames (string searchPattern)
 		{
-			FileInfo[] afi = directory.GetFiles (searchPattern);
+			if (searchPattern == null)
+				throw new ArgumentNullException ("searchPattern");
+
+			// note: IsolatedStorageFile accept a "dir/file" pattern which is not allowed by DirectoryInfo
+			// so we need to split them to get the right results
+			string path = Path.GetDirectoryName (searchPattern);
+			string pattern = Path.GetFileName (searchPattern);
+			FileInfo[] afi = null;
+			if (path == null || path.Length == 0) {
+				afi = directory.GetFiles (searchPattern);
+			} else {
+				DirectoryInfo[] subdirs = directory.GetDirectories (path);
+				// we're looking for a single result, identical to path (no pattern here)
+				// we're also looking for something under the current path (not outside isolated storage)
+				if ((subdirs.Length == 1) && (subdirs [0].Name == path) && (subdirs [0].FullName.IndexOf (directory.FullName) >= 0)) {
+					afi = subdirs [0].GetFiles (pattern);
+				} else {
+					// CAS, even in FullTrust, normally enforce IsolatedStorage
+					throw new SecurityException ();
+				}
+			}
+
 			return GetNames (afi);
 		}
 
