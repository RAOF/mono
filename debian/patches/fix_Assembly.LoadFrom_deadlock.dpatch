#! /bin/sh /usr/share/dpatch/dpatch-run
## fix_Assembly.LoadFrom_deadlock_r113458.dpatch by Mirco Bauer <meebey@debian.org>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: Fixes a deadlock in Assembly.LoadFrom(), see:
## DP: https://bugzilla.novell.com/show_bug.cgi?id=434289
## DP: https://bugzilla.novell.com/show_bug.cgi?id=323696
## DP: Backported from upstream SVN revisions:
## DP: r105036:
## DP: * assembly.c (mono_assembly_load_from_full): Avoid calling the search hooks
## DP: while holding the assemblies lock to prevent deadlocks. Handle the case
## DP: where the search hook returns NULL but the assembly was still loaded.
## DP: Fixes #323696.
## DP:
## DP: r105153:
## DP: 	* assembly.c (mono_assembly_loaded_full): Avoid calling the search hooks while
## DP:  holding the assemblies lock here too.
## DP:
## DP: r113458:
## DP: * class.c (can_access_internals): Call mono_assembly_load_friends ()
## DP: before accessing the friend_assembly_names field.
## DP: * assembly.c (mono_assembly_load_friends): Make this callable multiple
## DP: times.
## DP: (mono_assembly_load_from_full): Avoid calling load_friends (), it is
## DP: called lazily when it is needed.
## DP: * metadata-internals.h (struct _MonoAssembly): Add 
## DP: 'friend_assembly_names_inited' flag.
## DP:
## DP: r115451:
## DP: * assembly.c: in mono_assembly_load_friends() take the assemblies lock
## DP: for the least possible amount of time (extending the fix in r113458).
## DP:
## DP: r115697:
## DP: * assembly.c (mono_assembly_open_full): Avoid loading images while holding
## DP: the low level assemblies lock.

@DPATCH@
diff -urNad mono-1.9.1+dfsg~/mono/metadata/assembly.c mono-1.9.1+dfsg/mono/metadata/assembly.c
--- mono-1.9.1+dfsg~/mono/metadata/assembly.c	2008-10-13 22:43:51.000000000 +0200
+++ mono-1.9.1+dfsg/mono/metadata/assembly.c	2008-10-13 22:49:51.000000000 +0200
@@ -30,6 +30,7 @@
 #include <mono/metadata/mono-config.h>
 #include <mono/utils/mono-digest.h>
 #include <mono/utils/mono-logger.h>
+#include <mono/utils/mono-membar.h>
 #include <mono/metadata/reflection.h>
 
 #ifndef PLATFORM_WIN32
@@ -372,18 +373,6 @@
 	return TRUE;
 }
 
-static MonoAssembly*
-search_loaded (MonoAssemblyName* aname, gboolean refonly)
-{
-	MonoAssembly *ass;
-
-	ass = mono_assembly_invoke_search_hook_internal (aname, refonly, FALSE);
-	if (ass)
-		return ass;
-
-	return NULL;
-}
-
 static MonoAssembly *
 load_in_path (const char *basename, const char** search_path, MonoImageOpenStatus *status, MonoBoolean refonly)
 {
@@ -1282,11 +1271,8 @@
 	if (bundles != NULL)
 		image = mono_assembly_open_from_bundle (fname, status, refonly);
 
-	if (!image) {
-		mono_assemblies_lock ();
+	if (!image)
 		image = mono_image_open_full (fname, status, refonly);
-		mono_assemblies_unlock ();
-	}
 
 	if (!image){
 		if (*status == MONO_IMAGE_OK)
@@ -1320,8 +1306,14 @@
 	return ass;
 }
 
+static void
+free_item (gpointer val, gpointer user_data)
+{
+	g_free (val);
+}
+
 /*
- * mono_load_friend_assemblies:
+ * mono_assembly_load_friends:
  * @ass: an assembly
  *
  * Load the list of friend assemblies that are allowed to access
@@ -1336,9 +1328,32 @@
 mono_assembly_load_friends (MonoAssembly* ass)
 {
 	int i;
-	MonoCustomAttrInfo* attrs = mono_custom_attrs_from_assembly (ass);
-	if (!attrs)
+	MonoCustomAttrInfo* attrs;
+	GSList *list;
+
+	if (ass->friend_assembly_names_inited)
 		return;
+
+	attrs = mono_custom_attrs_from_assembly (ass);
+	if (!attrs) {
+		mono_assemblies_lock ();
+		ass->friend_assembly_names_inited = TRUE;
+		mono_assemblies_unlock ();
+		return;
+	}
+
+	mono_assemblies_lock ();
+	if (ass->friend_assembly_names_inited) {
+		mono_assemblies_unlock ();
+		return;
+	}
+	mono_assemblies_unlock ();
+
+	list = NULL;
+	/* 
+	 * We build the list outside the assemblies lock, the worse that can happen
+	 * is that we'll need to free the allocated list.
+	 */
 	for (i = 0; i < attrs->num_attrs; ++i) {
 		MonoCustomAttrEntry *attr = &attrs->attrs [i];
 		MonoAssemblyName *aname;
@@ -1357,12 +1372,26 @@
 		aname = g_new0 (MonoAssemblyName, 1);
 		/*g_print ("friend ass: %s\n", data);*/
 		if (mono_assembly_name_parse_full (data, aname, TRUE, NULL, NULL)) {
-			ass->friend_assembly_names = g_slist_prepend (ass->friend_assembly_names, aname);
+			list = g_slist_prepend (list, aname);
 		} else {
 			g_free (aname);
 		}
 	}
 	mono_custom_attrs_free (attrs);
+
+	mono_assemblies_lock ();
+	if (ass->friend_assembly_names_inited) {
+		mono_assemblies_unlock ();
+		g_slist_foreach (list, free_item, NULL);
+		g_slist_free (list);
+		return;
+	}
+	ass->friend_assembly_names = list;
+
+	/* Because of the double checked locking pattern above */
+	mono_memory_barrier ();
+	ass->friend_assembly_names_inited = TRUE;
+	mono_assemblies_unlock ();
 }
 
 /**
@@ -1441,14 +1470,12 @@
 	mono_trace (G_LOG_LEVEL_INFO, MONO_TRACE_ASSEMBLY, "Image addref %s %p -> %s %p: %d\n", ass->aname.name, ass, image->name, image, image->ref_count);
 
 	/* 
-	 * Atomically search the loaded list and add ourselves to it if necessary.
+	 * The load hooks might take locks so we can't call them while holding the
+	 * assemblies lock.
 	 */
-	mono_assemblies_lock ();
 	if (ass->aname.name) {
-		/* avoid loading the same assembly twice for now... */
-		ass2 = search_loaded (&ass->aname, refonly);
+		ass2 = mono_assembly_invoke_search_hook_internal (&ass->aname, refonly, FALSE);
 		if (ass2) {
-			mono_assemblies_unlock ();
 			g_free (ass);
 			g_free (base_dir);
 			mono_image_close (image);
@@ -1457,12 +1484,25 @@
 		}
 	}
 
-	g_assert (image->assembly == NULL);
+	mono_assemblies_lock ();
+
+	if (image->assembly) {
+		/* 
+		 * This means another thread has already loaded the assembly, but not yet
+		 * called the load hooks so the search hook can't find the assembly.
+		 */
+		mono_assemblies_unlock ();
+		ass2 = image->assembly;
+		g_free (ass);
+		g_free (base_dir);
+		mono_image_close (image);
+		*status = MONO_IMAGE_OK;
+		return ass2;
+	}
+
 	image->assembly = ass;
 
 	loaded_assemblies = g_list_prepend (loaded_assemblies, ass);
-	if (mono_defaults.internals_visible_class)
-		mono_assembly_load_friends (ass);
 	mono_assemblies_unlock ();
 
 	mono_assembly_invoke_load_hook (ass);
@@ -2301,9 +2341,7 @@
 
 	aname = mono_assembly_remap_version (aname, &maped_aname);
 
-	mono_assemblies_lock ();
-	res = search_loaded (aname, refonly);
-	mono_assemblies_unlock ();
+	res = mono_assembly_invoke_search_hook_internal (aname, refonly, FALSE);
 
 	return res;
 }
diff -urNad mono-1.9.1+dfsg~/mono/metadata/class.c mono-1.9.1+dfsg/mono/metadata/class.c
--- mono-1.9.1+dfsg~/mono/metadata/class.c	2008-10-13 22:43:51.000000000 +0200
+++ mono-1.9.1+dfsg/mono/metadata/class.c	2008-10-13 22:44:32.000000000 +0200
@@ -6238,6 +6238,7 @@
 		return TRUE;
 	if (!accessed || !accessing)
 		return FALSE;
+	mono_assembly_load_friends (accessed);
 	for (tmp = accessed->friend_assembly_names; tmp; tmp = tmp->next) {
 		MonoAssemblyName *friend = tmp->data;
 		/* Be conservative with checks */
diff -urNad mono-1.9.1+dfsg~/mono/metadata/metadata-internals.h mono-1.9.1+dfsg/mono/metadata/metadata-internals.h
--- mono-1.9.1+dfsg~/mono/metadata/metadata-internals.h	2008-10-13 22:43:51.000000000 +0200
+++ mono-1.9.1+dfsg/mono/metadata/metadata-internals.h	2008-10-13 22:44:32.000000000 +0200
@@ -25,7 +25,8 @@
 	MonoAssemblyName aname;
 	MonoDl *aot_module;
 	MonoImage *image;
-	GSList *friend_assembly_names;
+	GSList *friend_assembly_names; /* Computed by mono_assembly_load_friends () */
+	guint8 friend_assembly_names_inited;
 	guint8 in_gac;
 	guint8 dynamic;
 	guint8 corlib_internal;
